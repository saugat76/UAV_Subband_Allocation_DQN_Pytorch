diff --git a/__pycache__/uav_env.cpython-310.pyc b/__pycache__/uav_env.cpython-310.pyc
index e1e8842..862bee9 100644
Binary files a/__pycache__/uav_env.cpython-310.pyc and b/__pycache__/uav_env.cpython-310.pyc differ
diff --git a/dynamic_env/main.py b/dynamic_env/main.py
index b44d2d2..7bc715b 100644
--- a/dynamic_env/main.py
+++ b/dynamic_env/main.py
@@ -55,6 +55,21 @@ def parse_args():
 
     # Environment specific arguments 
     parser.add_argument("--info-exchange-lvl", type=int, default=1, help="information exchange level between UAVs: 1 -> implicit, 2 -> reward, 3 -> position with distance penalty, 4 -> state")
+    # Arguments for used inside the wireless UAV based enviornment  
+    parser.add_argument("--num-user", type=int, default=100, help="number of user in defined environment")
+    parser.add_argument("--num-uav", type=int, default=5, help="number of uav for the defined environment")
+    parser.add_argument("--generate-user-distribution", type=lambda x: bool(strtobool(x)), default=False, help="if true generate a new user distribution, set true if changing number of users")
+    parser.add_argument("--carrier-freq", type=int, default=2, help="set the frequency of the carrier signal in GHz")
+    parser.add_argument("--coverage-xy", type=int, default=1000, help="set the length of target area (square)")
+    parser.add_argument("--uav-height", type=int, default=350, help="define the altitude for all uav")
+    parser.add_argument("--theta", type=int, default=60, help="angle of coverage for a uav in degree")
+    parser.add_argument("--bw-uav", type=float, default=4e6, help="actual bandwidth of the uav")
+    parser.add_argument("--bw-rb", type=float, default=180e3, help="bandwidth of a resource block")
+    parser.add_argument("--grid-space", type=int, default=100, help="seperating space for grid")
+    parser.add_argument("--uav-dis-th", type=int, default=1000, help="distance value that defines which uav agent share info")
+    parser.add_argument("--dist-pri-param", type=float, default=1/5, help="distance penalty priority parameter used in level 3 info exchange")
+    
+    args = parser.parse_args()
 
     args = parser.parse_args()
 
@@ -176,7 +191,7 @@ if __name__ == "__main__":
     user_loc_1 = np.loadtxt('UserLocation_1.txt', delimiter=' ').astype(np.int64)
     user_loc_2 = np.loadtxt('UserLocation_2.txt', delimiter=' ').astype(np.int64)
 
-    u_env = UAVenv(user_loc=user_loc_1)
+    u_env = UAVenv(args, user_loc=user_loc_1)
     GRID_SIZE = u_env.GRID_SIZE
     NUM_UAV = u_env.NUM_UAV
     NUM_USER = u_env.NUM_USER
@@ -437,7 +452,7 @@ if __name__ == "__main__":
     plt.plot(range(0, num_episode), episode_user_connected)
     plt.xlabel("Episode")
     plt.ylabel("Connected User in Episode")
-    plt.title("Episode vs Connected User in Epsisode")
+    plt.title("Episode vs Connected User in Episode")
     plt.savefig(custom_dir + f'\episode_vs_connected_users.png')
     plt.close()
     # Episodic Reward vs Episodes (Smoothed)
diff --git a/dynamic_env/uav_env.py b/dynamic_env/uav_env.py
index dc6daf5..cf6f301 100644
--- a/dynamic_env/uav_env.py
+++ b/dynamic_env/uav_env.py
@@ -6,9 +6,6 @@ import gym
 import numpy as np
 import math
 import matplotlib.pyplot as plt
-import time 
-import random
-
 
 ###################################
 ##     UAV Class Defination      ##
@@ -101,8 +98,31 @@ class UAVenv(gym.Env):
 
     USER_RB_REQ = np.loadtxt('UserRBReq.txt', delimiter=' ').astype(np.int64)
 
-    def __init__(self, user_loc):
+    def __init__(self, args, user_loc):
         super(UAVenv, self).__init__()
+
+        # Environment specific params 
+        self.args = args
+        self.NUM_USER = self.args.num_user                      # Number of ground user
+        self.NUM_UAV = self.args.num_uav                        # Number of UAV
+        Fc = self.args.carrier_freq                             # Operating Frequency 2 GHz
+        LightSpeed = 3 * (10 ** 8)                              # Speed of Light
+        self.WaveLength = LightSpeed / (Fc * (10 ** 9))         # Wavelength of the wave
+        self.COVERAGE_XY = self.args.coverage_xy
+        self.UAV_HEIGHT = self.args.uav_height
+        self.BS_LOC = np.zeros((self.NUM_UAV, 3))
+        self.THETA = self.args.theta * math.pi / 180            # In radian  // Bandwidth for a resource block (This value is representing 2*theta instead of theta)
+        self. BW_UAV = self.args.bw_uav                         # Total Bandwidth per UAV   
+        self.BW_RB = self.args.bw_rb                            # Bandwidth of a Resource Block
+        self.ACTUAL_BW_UAV = self.BW_UAV * 0.9
+        self.grid_space = self.args.grid_space
+        self.GRID_SIZE = int(self.COVERAGE_XY / self.grid_space)# Each grid defined as 100m block
+        self.UAV_DIST_THRS = self.args.uav_dis_th               # Distnce that defines the term "neighbours" // UAV closer than this distance share their information
+        self.dis_penalty_pri = self.args.dist_pri_param         # Priority value for defined for the distance penalty // 
+                                                                # // Value ranges from 0 (overlapping UAV doesnot affect reward) to 1 (Prioritizes overlapping area as negative reward to full extent)
+
+
+
         # Defining action spaces // UAV RB allocation to each user increase each by 1 untill remains
         # Five different action for the movement of each UAV
         # 0 = Right, 1 = Left, 2 = straight, 3 = back, 4 = Hover
@@ -292,9 +312,9 @@ class UAVenv(gym.Env):
             reward = 0
             for k in range(self.NUM_UAV):
                 if self.flag[k] != 0:
-                    sum_user_assoc_temp[k] -= 2
                     temp_user_id = np.where(dist_uav_uav[k, :] <= self.UAV_DIST_THRS)
                     reward_ind[k] = np.average(sum_user_assoc_temp[temp_user_id])
+                    reward_ind[k] -= 2
                     isDone = True
                 else:
                     temp_user_id = np.where(dist_uav_uav[k, :] <= self.UAV_DIST_THRS)
diff --git a/main.py b/main.py
index 4bf06ae..e7a229b 100644
--- a/main.py
+++ b/main.py
@@ -55,7 +55,20 @@ def parse_args():
 
     # Environment specific arguments 
     parser.add_argument("--info-exchange-lvl", type=int, default=1, help="information exchange level between UAVs: 1 -> implicit, 2 -> reward, 3 -> position with distance penalty, 4 -> state")
-
+    # Arguments for used inside the wireless UAV based enviornment  
+    parser.add_argument("--num-user", type=int, default=100, help="number of user in defined environment")
+    parser.add_argument("--num-uav", type=int, default=5, help="number of uav for the defined environment")
+    parser.add_argument("--generate-user-distribution", type=lambda x: bool(strtobool(x)), default=False, help="if true generate a new user distribution, set true if changing number of users")
+    parser.add_argument("--carrier-freq", type=int, default=2, help="set the frequency of the carrier signal in GHz")
+    parser.add_argument("--coverage-xy", type=int, default=1000, help="set the length of target area (square)")
+    parser.add_argument("--uav-height", type=int, default=350, help="define the altitude for all uav")
+    parser.add_argument("--theta", type=int, default=60, help="angle of coverage for a uav in degree")
+    parser.add_argument("--bw-uav", type=float, default=4e6, help="actual bandwidth of the uav")
+    parser.add_argument("--bw-rb", type=float, default=180e3, help="bandwidth of a resource block")
+    parser.add_argument("--grid-space", type=int, default=100, help="seperating space for grid")
+    parser.add_argument("--uav-dis-th", type=int, default=1000, help="distance value that defines which uav agent share info")
+    parser.add_argument("--dist-pri-param", type=float, default=1/5, help="distance penalty priority parameter used in level 3 info exchange")
+    
     args = parser.parse_args()
 
     return args
@@ -165,7 +178,7 @@ class DQL:
 
 if __name__ == "__main__":
     args = parse_args()
-    u_env = UAVenv()
+    u_env = UAVenv(args)
     GRID_SIZE = u_env.GRID_SIZE
     NUM_UAV = u_env.NUM_UAV
     NUM_USER = u_env.NUM_USER
@@ -406,12 +419,12 @@ if __name__ == "__main__":
     plt.title("Episode vs Episodic Reward")
     plt.savefig(custom_dir + f'\episode_vs_reward.png')
     plt.close()
-    # Epsiode vs Connected Users
+    # Episode vs Connected Users
     fig_2 = plt.figure()
     plt.plot(range(0, num_episode), episode_user_connected)
     plt.xlabel("Episode")
     plt.ylabel("Connected User in Episode")
-    plt.title("Episode vs Connected User in Epsisode")
+    plt.title("Episode vs Connected User in Episode")
     plt.savefig(custom_dir + f'\episode_vs_connected_users.png')
     plt.close()
     # Episodic Reward vs Episodes (Smoothed)
diff --git a/run.py b/run.py
index e8a533d..a8362c6 100644
--- a/run.py
+++ b/run.py
@@ -6,4 +6,12 @@ for i in range(1, 5):
     print('####  Running the code for Level:', i, "info exchange  ####")
     print('#######################################################')
     p = subprocess.run(["python", "uav_env.py"])
-    g = subprocess.run(["python", "main.py", "--info-exchange-lvl", str(i), "--wandb-track", "True"])
\ No newline at end of file
+    g = subprocess.run(["python", "main.py", "--info-exchange-lvl", str(i), "--num-episode", str(450), "--wandb-track", "True", "--learning-rate", str(1e-4)])
+
+# ## Running for level 3 with different distance values
+for i in range(0,1000, 250):
+    print('###########################################################')
+    print('####  Running the code for distance threshold:', i, " with Level: 2 ####")
+    print('###########################################################')
+    p = subprocess.run(["python", "uav_env.py"])
+    g = subprocess.run(["python", "main.py", "--info-exchange-lvl", str(2), "--num-episode", str(800), "--wandb-track", "True", "--uav-dis-th", str(i), "--learning-rate", str(1e-4)])
diff --git a/uav_env.py b/uav_env.py
index 80138a6..dd8bf69 100644
--- a/uav_env.py
+++ b/uav_env.py
@@ -8,7 +8,6 @@ import math
 import matplotlib.pyplot as plt
 import time 
 
-
 ###################################
 ##     UAV Class Defination      ##
 ###################################
@@ -16,24 +15,6 @@ import time
 class UAVenv(gym.Env):
     """Custom Environment that follows gym interface """
     metadata = {'render.modes': ['human']}
-    # Fixed Input Parameters
-    NUM_USER = 100                          # Number of ground user
-    NUM_UAV = 5                             # Number of UAV
-    Fc = 2                                  # Operating Frequency 2 GHz
-    LightSpeed = 3 * (10 ** 8)              # Speed of Light
-    WaveLength = LightSpeed / (Fc * (10 ** 9))  # Wavelength of the wave
-    COVERAGE_XY = 1000
-    UAV_HEIGHT = 350
-    BS_LOC = np.zeros((NUM_UAV, 3))
-    THETA = 60 * math.pi / 180              # In radian  // Bandwidth for a resource block (This value is representing 2*theta instead of theta)
-    BW_UAV = 4e6                            # Total Bandwidth per UAV   
-    BW_RB = 180e3                           # Bandwidth of a Resource Block
-    ACTUAL_BW_UAV = BW_UAV * 0.9
-    grid_space = 100
-    GRID_SIZE = int(COVERAGE_XY / grid_space)  # Each grid defined as 100m block
-    UAV_DIST_THRS = 1000                     # Distnce that defines the term "neighbours" // UAV closer than this distance share their information
-    dis_penalty_pri = (1/5)                 # Priority value for defined for the distance penalty // 
-                                            # // Value ranges from 0 (overlapping UAV doesnot affect reward) to 1 (Prioritizes overlapping area as negative reward to full extent)                                          
 
     ## Polar to Cartesian and vice versa
     def pol2cart(r,theta):
@@ -45,10 +26,8 @@ class UAVenv(gym.Env):
     ############################################################################
     ##     First User Distribution // Hotspots with Uniform Distribution      ##
     ############################################################################
-
     # User distribution on the target area // NUM_USER/5 users in each of four hotspots
     # Remaining NUM_USER/5 is then uniformly distributed in the target area
-
     # HOTSPOTS = np.array(
     #     [[200, 200], [800, 800], [300, 800], [800, 300]])  # Position setup in grid size rather than actual distance
     # USER_DIS = int(NUM_USER / NUM_UAV)
@@ -89,13 +68,35 @@ class UAVenv(gym.Env):
     
     USER_RB_REQ = np.loadtxt('UserRBReq.txt', delimiter=' ').astype(np.int64)
 
-    def __init__(self):
+    def __init__(self, args):
         super(UAVenv, self).__init__()
+         
+        # Environment specific params 
+        self.args = args
+        self.NUM_USER = self.args.num_user                      # Number of ground user
+        self.NUM_UAV = self.args.num_uav                        # Number of UAV
+        Fc = self.args.carrier_freq                             # Operating Frequency 2 GHz
+        LightSpeed = 3 * (10 ** 8)                              # Speed of Light
+        self.WaveLength = LightSpeed / (Fc * (10 ** 9))         # Wavelength of the wave
+        self.COVERAGE_XY = self.args.coverage_xy
+        self.UAV_HEIGHT = self.args.uav_height
+        self.BS_LOC = np.zeros((self.NUM_UAV, 3))
+        self.THETA = self.args.theta * math.pi / 180            # In radian  // Bandwidth for a resource block (This value is representing 2*theta instead of theta)
+        self. BW_UAV = self.args.bw_uav                         # Total Bandwidth per UAV   
+        self.BW_RB = self.args.bw_rb                            # Bandwidth of a Resource Block
+        self.ACTUAL_BW_UAV = self.BW_UAV * 0.9
+        self.grid_space = self.args.grid_space
+        self.GRID_SIZE = int(self.COVERAGE_XY / self.grid_space)# Each grid defined as 100m block
+        self.UAV_DIST_THRS = self.args.uav_dis_th               # Distnce that defines the term "neighbours" // UAV closer than this distance share their information
+        self.dis_penalty_pri = self.args.dist_pri_param         # Priority value for defined for the distance penalty // 
+                                                                # // Value ranges from 0 (overlapping UAV doesnot affect reward) to 1 (Prioritizes overlapping area as negative reward to full extent)
+
+
         # Defining action spaces // UAV RB allocation to each user increase each by 1 untill remains
         # Five different action for the movement of each UAV
         # 0 = Right, 1 = Left, 2 = straight, 3 = back, 4 = Hover
         # Defining Observation spaces // UAV RB to each user
-        # Position of the UAV in space // X and Y pos
+        # Position of the UAV in space // X and Y pos                                          
         self.u_loc = self.USER_LOC
         self.state = np.zeros((self.NUM_UAV, 3), dtype=np.int32)
         # Set the states to the hotspots and one at the centre for faster convergence
@@ -280,9 +281,9 @@ class UAVenv(gym.Env):
             reward = 0
             for k in range(self.NUM_UAV):
                 if self.flag[k] != 0:
-                    sum_user_assoc_temp[k] -= 2
                     temp_user_id = np.where(dist_uav_uav[k, :] <= self.UAV_DIST_THRS)
                     reward_ind[k] = np.average(sum_user_assoc_temp[temp_user_id])
+                    reward_ind[k] -= 2
                     isDone = True
                 else:
                     temp_user_id = np.where(dist_uav_uav[k, :] <= self.UAV_DIST_THRS)
